==============================此2模板解决二分全部问题=====================================题目===================================================================================================================
789. 数的范围

给定一个按照升序排列的长度为 n 的整数数组，以及 q 个查询。

对于每个查询，返回一个元素 k 的起始位置和终止位置（位置从 0 开始计数）。

如果数组中不存在该元素，则返回 -1 -1。

输入格式
第一行包含整数 n 和 q，表示数组长度和询问个数。

第二行包含 n 个整数（均在 1∼10000 范围内），表示完整数组。

接下来 q 行，每行包含一个整数 k，表示一个询问元素。

输出格式
共 q 行，每行包含两个整数，表示所求元素的起始位置和终止位置。

如果数组中不存在该元素，则返回 -1 -1。

数据范围
1≤n≤100000
1≤q≤10000
1≤k≤10000
输入样例：
6 3
1 2 2 3 3 4
3
4
5
输出样例：
3 4
5 5
-1 -1


========================================================================代码（整型2分）=================================================================================
#include<stdio.h>


int main()
{
    int n,m,mid;
    int arr[100010];
    scanf("%d",&n);//数组长度
    scanf("%d",&m);//查询次数
    int i = 0;
    for(i=0;i<n;i++) scanf("%d",&arr[i]);//录入
    while(m--)
    {
        int x;
        scanf("%d",&x);
          //++++++++++++++++++++++++++++++++++++++++++模板1+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++若x = 5， 卡12555中最左边的5
        int l = 0;
        int r = n-1;
        while(l<r)//找 x x x 中第一个x  所以mid = l+r>>1 默认向左取整的~ 所以 》=的话  r=给到mid 最后能卡出eg 1，2，3，3，3中最左边的3的下标！
        {
            int mid = l+r>>1;
            if(arr[mid]>=x) r=mid;
            else l=mid+1;
        }
        
        if(x!=arr[l]) printf("-1 -1\n");//判断数组中有没x
        
        else
        {
            printf("%d ",l);
            //++++++++++++++++++++++++++++++++++++++++++模板2+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++若 x = 5，卡12555中最右边的5
            l=0,r=n-1;
            while(l<r) //找 XXX 中 最后一个X  所以 mid = l+r>>1 默认向下（右）取整的~ 所以 《=x的话  l=给到mid 最后能卡出eg 1，2，3，3，3中最左边的3的下标！
        {
            {
            
                mid = l+r+1>>1;
                if(arr[mid]<=x) l=mid; 
                else r=mid-1;
                
            }
            printf("%d\n",l);
        }
    }
    
    
    
    //注意  二分钟 判断语句》= or 《= 右=的原因是 保证每次 保留下来的一段中 要包含答案噢。。   快排是do while（反条件，< or > ） 这样 卡出 >=x的i 和 <=x的 j然后交换
    
    
    return 0;
}

========================================================================代码（实型！！2分）=================================================================================

求7的平方根？  实型的/  不会取整  所以很nice
(同理  什么1 2 3 4 5 6 次方根都能求  ，每次卡一半  还很快！！！二分yyds)

#include <stdio.h>
int main()
{  //用double 因为精度高哦
    double r = 7;    //注意   负数 或者 -1《x《1 eg 0.01  这样需要特判  （小bug）  因为0.01的平方根是0.1 并不是在 0~0.01范围内哈哈哈
    double l = 0;
    
    while(l<r)
    {
        double mid = l+r>>1;
        if(mid*mid（求平方根 所以mid^2）>=7) r=mid;
        else l = mid +1;
    }
    printf("%lf",l); //注意精度
}

