//爬n接台阶,可以理解为最后一次是爬一个台阶,那么前面就是n-1阶台阶有多少种爬法.最后一次爬两个台阶,那么前面就是n-2种爬法
 
（归纳思想）

核心思想     不管怎么复杂  最后上到顶部的那一次 不是跨1步就是跨2步   则逆序思想   n阶台阶 跨完最后一步上去的时候   屁股后面有n-1（若最后一步为1） or n-2（若最后一步为2）阶台阶等着你跨


#include <stdio.h>
#include <stdlib.h>

int main()
{
    int n,i;
    scanf("%d",&n);
    int* arr=(int*)malloc(4*n+1);
    arr[0]=1;              //注意这里  很特殊 因为n=2需要 1+1               
    arr[1]=1;             //这两个特殊的 给他直接赋值进去   
    for(i=2;i<=n;i++)        假设n=3 则 要么case1 最后1布 则3-1=2 就变成n=2的情况了   为2（1（arr[2-2]=1 最后一次上两部）+arr[2-1]=1(最后一次上一步)）                        假设n为99  那么 3呀4呀5呀都可以通过 arr[i]=arr[i-1]+arr[i-2];求得  最后arr[n]=    arr[n-1]+arr[n-2] 即可算出.
                                         要么case2 最后2布 则3-2=1 就变成n=1的情况了   为1  （最后一次上两部）
                                         这里需要   总方法：case1+case2 =3 因为是或（分类讨论的关系）！
    {
        arr[i]=arr[i-1]+arr[i-2];
    }
    printf("%d\n",arr[n]);// n位置就是n从n-1 n-2 类加上去的   arr[n]就为n阶台阶的总上法
    
    return 0;
}
