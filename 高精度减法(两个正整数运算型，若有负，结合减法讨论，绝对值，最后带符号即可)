
#define _CRT_SECURE_NO_WARNINGS 1
#include <stdio.h>
#include <string.h>
// 高精度减法！！前提 大减小  eeg：    a<b    a - b = -(b-a)    a>b  a-b = a-b 直接减
//其实 c++ 中的 vctor容器 很好的解决了数组动态的长度 边界问题，，，
================================================================从低位开始的核心操作部分====================================================================================
char* Sub(char a[], char b[], int alen, int blen, int c[])
{
	int t = 0;
	int i = 0;
	for (i = 0; i < alen; i++)
	{
		t = (a[i]-'0') - t;   //t在这里充当借位，和 临时变量 位操完压入c中的作用！
		if (i < blen) t -=(b[i]-'0');

		c[i] = (t + 10) % 10;//核心 自己里  分借位 和 不借位情况。一行搞定//(一行搞定借位制度)		if (t < 0) t = 1;
		if (t < 0) t = 1; // 借前面的那一位
		else t = 0;
	}
	return c;
}
============================================================================================================================================================================================================================================================================

int main()
 {
	int i = 0, j = 0;

	//以字符数组倒着录入长整数
	char a[10010], b[10010];
	char ta[10010], tb[10010];
	int c[100] = { 0 }; //注意 最后 整的是一个整型数组!  因为 % 放入每位的操作%  只能是整数

	scanf(" %s", a);
	int alen = strlen(a);
	scanf(" %s", b);
	int blen = strlen(b);
	int max = (alen > blen ? alen : blen); 
	for (j = 0, i = alen - 1; i >= 0; i--)
	{
		ta[j++] = a[i];
	}
	for (j = 0, i = blen - 1; i >= 0; i--)
	{
		tb[j++] = b[i];
	}

	Sub(ta, tb, alen, blen, c);


	
	for (i =  max- 1; i >= 0; i--) printf("%d", c[i]);

	return 0;
}
